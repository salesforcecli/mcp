{
  "description": "PMD Apex AST Nodes - Complete Reference",
  "source": "Extracted from PMD 7.18.0 source code",
  "extraction_date": "2025-12-03",
  "total_nodes": 97,
  "note": "Nodes contain only direct attributes. Inherited attributes are stored once in inheritSchema. Nodes reference parent classes via 'inherits' field. ",
  "important_notes": [
    {
      "title": "Method Node Name",
      "content": "Use @Image for Method node names, NOT @Name. @Name attribute does not exist for Method nodes."
    },
    {
      "title": "Interface vs Inheritance",
      "content": "Use @InterfaceNames (array) for interfaces, @SuperClassName for inheritance. @SuperClassName is empty string when no superclass exists. For array attributes like @InterfaceNames, use = operator to check membership: @InterfaceNames = 'Database.Batchable'."
    },
    {
      "title": "MethodCallExpression",
      "content": "Use @FullMethodName (NOT @MethodName) for MethodCallExpression. @FullMethodName excludes parentheses (e.g., 'Test.isRunningTest' not 'Test.isRunningTest()'). Use ancestor::Method//MethodCallExpression to search within same method context."
    },
    {
      "title": "SoqlExpression vs MethodCallExpression",
      "content": "SoqlExpression is ONLY created for literal SOQL queries in square brackets (e.g., [SELECT Id FROM Account]). Dynamic queries via method calls (e.g., Database.query(stringVariable)) create MethodCallExpression, not SoqlExpression."
    },
    {
      "title": "Test Detection",
      "content": "Use ModifierNode/@isTest for test classes/methods, NOT contains(@Image, 'Test'). String matching causes false positives. Check both class and method: not(ancestor::UserClass[ModifierNode/@isTest]) and not(ancestor::Method[ModifierNode/@isTest])."
    },
    {
      "title": "XPath Node Selection",
      "content": "XPath must return nodes, not booleans. Place predicates inside node selectors: //Node[@attr = 'value' and condition], NOT //Node[@attr = 'value'] and condition."
    },
    {
      "title": "Union Operator vs Boolean Operators",
      "content": "When combining multiple node selectors, use the union operator | (pipe) to return a node set, NOT the boolean operator 'or'. The 'or' operator returns true/false (boolean), which causes PMD errors: 'XPath rule expression returned a non-node (class net.sf.saxon.value.BooleanValue)'. Use | to combine node selectors that should all be matched, ensuring the XPath returns a node set rather than a boolean value."
    },
    {
      "title": "XPath Navigation and String Matching",
      "content": "Use ancestor::Node for containing context (e.g., ancestor::Method, ancestor::UserClass) and descendant::Node for contained elements. Use string functions on @Image (preserves casing): ends-with(@Image, 'Exception'), contains(@Image, 'Value'). For method-scoped searches: ancestor::Method//MethodCallExpression."
    },
    {
      "title": "Try-Catch Block Detection",
      "content": "Use descendant::TryCatchFinallyBlockStatement to check if a method contains try-catch. Check within method scope, not class scope. To check if a statement is wrapped in try-catch, use ancestor::TryCatchFinallyBlockStatement from the statement node to traverse up the AST tree and verify containment."
    },
    {
      "title": "Empty String Behavior",
      "content": "When checking for absence, use not(@attr = 'value') for string attributes. For @SuperClassName, empty string means no superclass, so not(@SuperClassName = 'Exception') correctly identifies classes that don't extend Exception."
    },
    {
      "title": "Node Type Names",
      "content": "Use UserClass (not ClassNode) for Apex classes, UserTrigger (not TriggerNode) for triggers. These are the correct node type names in PMD Apex AST."
    },
    {
      "title": "Node Attributes and Relationships",
      "content": "Only use attributes that exist for the specific node type (check AST reference). Non-existent attributes cause XPath to fail silently. Understand parent-child relationships: annotations are descendants of methods, not parents. Use descendant::Annotation within methods: //Method[descendant::Annotation[@Image = 'AuraEnabled']]."
    },
    {
      "title": "XPath Logic and Negation",
      "content": "Ensure XPath matches rule intent: use positive conditions for violations (e.g., @ReturnType = 'void'), negative for correct code (e.g., not(@ReturnType = 'void')). Use not(descendant::Node) to check absence. Combine conditions with 'and'. Verify XPath flags violations, not correct code."
    }
  ],
  "inheritSchema": {
    "BaseApexClass": [
      {
        "name": "@Image",
        "type": "string"
      },
      {
        "name": "@SimpleName",
        "type": "string"
      },
      {
        "name": "@QualifiedName",
        "type": "string"
      }
    ],
    "AbstractApexCommentContainerNode": [
      {
        "name": "@ContainsComment",
        "type": "boolean"
      }
    ],
    "AbstractApexNode": [
      {
        "name": "@RealLoc",
        "type": "boolean"
      },
      {
        "name": "@DefiningType",
        "type": "string"
      }
    ],
    "AbstractApexNode.Single": [
      {
        "name": "@RealLoc",
        "type": "boolean"
      },
      {
        "name": "@DefiningType",
        "type": "string"
      }
    ],
    "AbstractApexNode.Many": [
      {
        "name": "@RealLoc",
        "type": "boolean"
      },
      {
        "name": "@DefiningType",
        "type": "string"
      }
    ],
    "AbstractApexNode.Empty": [
      {
        "name": "@RealLoc",
        "type": "boolean"
      },
      {
        "name": "@DefiningType",
        "type": "string"
      }
    ]
  },
  "nodes": {
    "Annotation": {
      "name": "Annotation",
      "description": "Represents an annotation like @AuraEnabled, @TestVisible, @InvocableMethod",
      "category": "Modifiers",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Name",
          "type": "string",
          "description": "Returns the normalized annotation name for known, valid annotations. The normalized name is in PascalCase. If an unknown annotation is used, the raw name (as in the source code) is returned."
        },
        {
          "name": "@RawName",
          "type": "string",
          "description": "Returns the annotation name as it appears in the source code. This allows to verify the casing."
        },
        {
          "name": "@Image",
          "type": "string",
          "description": "Returns the annotation name as it appears in the source code. This allows to verify the casing."
        },
        {
          "name": "@isResolved",
          "type": "boolean",
          "description": "Returns the annotation name as it appears in the source code. This allows to verify the casing."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "AnnotationParameter": {
      "name": "AnnotationParameter",
      "description": "Represents a parameter of an annotation",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Name",
          "type": "string",
          "description": "The name of this node"
        },
        {
          "name": "@Value",
          "type": "string",
          "description": "The value of this node"
        },
        {
          "name": "@BooleanValue",
          "type": "boolean",
          "description": "The booleanvalue of this node"
        },
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        },
        {
          "name": "@Name",
          "type": "boolean",
          "description": "Checks whether this annotation parameter has the given name. The check is done case-insensitive.",
          "parameters": [
            "@NonNull String name"
          ]
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "AnonymousClass": {
      "name": "AnonymousClass",
      "description": "Represents anonymous class",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ApexFile": {
      "name": "ApexFile",
      "description": "Represents apex file",
      "category": "Other",
      "extends": "AbstractApexNode.Single",
      "implements": [
        "RootNode"
      ],
      "attributes": [
        {
          "name": "@AstInfo",
          "type": "string",
          "description": "The astinfo of this node"
        },
        {
          "name": "@MainNode",
          "type": "string",
          "description": "The mainnode of this node"
        },
        {
          "name": "@GlobalIssues",
          "type": "array",
          "description": "The globalissues of this node"
        },
        {
          "name": "@DefiningType",
          "type": "string",
          "description": "The definingtype of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ArrayLoadExpression": {
      "name": "ArrayLoadExpression",
      "description": "Represents array load expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ArrayStoreExpression": {
      "name": "ArrayStoreExpression",
      "description": "Represents array store expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "AssignmentExpression": {
      "name": "AssignmentExpression",
      "description": "Represents assignment expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Op",
          "type": "string",
          "description": "The op of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "BinaryExpression": {
      "name": "BinaryExpression",
      "description": "Represents a binary expression (operations with two operands like ==, !=, +, -, &&, ||)",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Op",
          "type": "string",
          "description": "The op of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "BindExpressions": {
      "name": "BindExpressions",
      "description": "Represents bind expressions",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "BlockStatement": {
      "name": "BlockStatement",
      "description": "Represents block statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@CurlyBrace",
          "type": "boolean",
          "description": "Whether this node hasCurlyBrace"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "BooleanExpression": {
      "name": "BooleanExpression",
      "description": "Represents boolean expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Op",
          "type": "string",
          "description": "The op of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "BreakStatement": {
      "name": "BreakStatement",
      "description": "Represents break statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "CastExpression": {
      "name": "CastExpression",
      "description": "Represents cast expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Type",
          "type": "string",
          "description": "Returns the target type name of the cast expression."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "CatchBlockStatement": {
      "name": "CatchBlockStatement",
      "description": "Represents catch block statement",
      "category": "Statements",
      "extends": "AbstractApexCommentContainerNode",
      "implements": [],
      "attributes": [
        {
          "name": "@ExceptionType",
          "type": "string",
          "description": "The exceptiontype of this node"
        },
        {
          "name": "@VariableName",
          "type": "string",
          "description": "The variablename of this node"
        },
        {
          "name": "@Body",
          "type": "string",
          "description": "The body of this node"
        }
      ],
      "inherits": [
        "AbstractApexCommentContainerNode",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ClassRefExpression": {
      "name": "ClassRefExpression",
      "description": "Represents class ref expression",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ConstructorPreamble": {
      "name": "ConstructorPreamble",
      "description": "Represents constructor preamble",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ConstructorPreambleStatement": {
      "name": "ConstructorPreambleStatement",
      "description": "Represents constructor preamble statement",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ContinueStatement": {
      "name": "ContinueStatement",
      "description": "Represents continue statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "DmlDeleteStatement": {
      "name": "DmlDeleteStatement",
      "description": "Represents a DML delete operation",
      "category": "Statements",
      "extends": "AbstractDmlStatement",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractDmlStatement",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "DmlInsertStatement": {
      "name": "DmlInsertStatement",
      "description": "Represents a DML insert operation",
      "category": "Statements",
      "extends": "AbstractDmlStatement",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractDmlStatement",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "DmlMergeStatement": {
      "name": "DmlMergeStatement",
      "description": "Represents dml merge statement",
      "category": "Statements",
      "extends": "AbstractDmlStatement",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractDmlStatement",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "DmlUndeleteStatement": {
      "name": "DmlUndeleteStatement",
      "description": "Represents dml undelete statement",
      "category": "Statements",
      "extends": "AbstractDmlStatement",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractDmlStatement",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "DmlUpdateStatement": {
      "name": "DmlUpdateStatement",
      "description": "Represents a DML update operation",
      "category": "Statements",
      "extends": "AbstractDmlStatement",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractDmlStatement",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "DmlUpsertStatement": {
      "name": "DmlUpsertStatement",
      "description": "Represents dml upsert statement",
      "category": "Statements",
      "extends": "AbstractDmlStatement",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractDmlStatement",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "DoLoopStatement": {
      "name": "DoLoopStatement",
      "description": "Represents do loop statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ElseWhenBlock": {
      "name": "ElseWhenBlock",
      "description": "Represents else when block",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "EmptyReferenceExpression": {
      "name": "EmptyReferenceExpression",
      "description": "Represents empty reference expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Empty",
      "implements": [],
      "attributes": [
        {
          "name": "@DefiningType",
          "type": "string",
          "description": "The definingtype of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Empty",
        "AbstractApexNode"
      ]
    },
    "Expression": {
      "name": "Expression",
      "description": "Represents expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ExpressionStatement": {
      "name": "ExpressionStatement",
      "description": "Represents expression statement",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "Field": {
      "name": "Field",
      "description": "Represents field",
      "category": "Declarations",
      "extends": "AbstractApexNode.Many",
      "implements": [],
      "attributes": [
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        },
        {
          "name": "@Type",
          "type": "string",
          "description": "Returns the type name. <p>This includes any type arguments. (This is tested.) If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@Modifiers",
          "type": "node",
          "description": "Returns the type name. <p>This includes any type arguments. (This is tested.) If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@Name",
          "type": "string",
          "description": "Returns the type name. <p>This includes any type arguments. (This is tested.) If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@Value",
          "type": "string",
          "description": "Returns the type name. <p>This includes any type arguments. (This is tested.) If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@RealLoc",
          "type": "boolean",
          "description": "Returns the type name. <p>This includes any type arguments. (This is tested.) If the type is a primitive, its case will be normalized."
        }
      ],
      "inherits": [
        "AbstractApexNode.Many",
        "AbstractApexNode"
      ]
    },
    "FieldDeclaration": {
      "name": "FieldDeclaration",
      "description": "Represents field declaration",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        },
        {
          "name": "@Name",
          "type": "string",
          "description": "The name of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "FieldDeclarationStatements": {
      "name": "FieldDeclarationStatements",
      "description": "Represents field declaration statements",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Modifiers",
          "type": "node",
          "description": "The modifiers of this node"
        },
        {
          "name": "@TypeName",
          "type": "string",
          "description": "Returns the type name. <p>This includes any type arguments. If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@TypeArguments",
          "type": "array",
          "description": "This returns the first level of the type arguments. If there are nested types (e.g. {@code List<List<String>>}), then these returned types contain themselves type arguments. <p>Note: This method only exists for this AST type and in no other type, even though type arguments are possible e.g. for {@link ASTVariableDeclaration#getType()}."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ForEachStatement": {
      "name": "ForEachStatement",
      "description": "Represents for each statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ForLoopStatement": {
      "name": "ForLoopStatement",
      "description": "Represents a for loop statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "FormalComment": {
      "name": "FormalComment",
      "description": "Represents formal comment",
      "category": "Statements",
      "extends": "AbstractApexNode.Empty",
      "implements": [],
      "attributes": [
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Empty",
        "AbstractApexNode"
      ]
    },
    "IdentifierCase": {
      "name": "IdentifierCase",
      "description": "Represents identifier case",
      "category": "Other",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "IfBlockStatement": {
      "name": "IfBlockStatement",
      "description": "Represents an if statement block",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "IfElseBlockStatement": {
      "name": "IfElseBlockStatement",
      "description": "Represents if else block statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@ElseStatement",
          "type": "boolean",
          "description": "Whether this node hasElseStatement"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "IllegalStoreExpression": {
      "name": "IllegalStoreExpression",
      "description": "Represents illegal store expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "InstanceOfExpression": {
      "name": "InstanceOfExpression",
      "description": "Represents instance of expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "InvalidDependentCompilation": {
      "name": "InvalidDependentCompilation",
      "description": "Represents invalid dependent compilation",
      "category": "Other",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "JavaMethodCallExpression": {
      "name": "JavaMethodCallExpression",
      "description": "Represents java method call expression",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "JavaVariableExpression": {
      "name": "JavaVariableExpression",
      "description": "Represents java variable expression",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "LiteralCase": {
      "name": "LiteralCase",
      "description": "Represents literal case",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "LiteralExpression": {
      "name": "LiteralExpression",
      "description": "Represents a literal value (string, number, boolean, null)",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@LiteralType",
          "type": "string",
          "description": "The literaltype of this node"
        },
        {
          "name": "@isString",
          "type": "boolean",
          "description": "Whether this node isString"
        },
        {
          "name": "@isBoolean",
          "type": "boolean",
          "description": "Whether this node isBoolean"
        },
        {
          "name": "@isInteger",
          "type": "boolean",
          "description": "Whether this node isInteger"
        },
        {
          "name": "@isDouble",
          "type": "boolean",
          "description": "Whether this node isDouble"
        },
        {
          "name": "@isLong",
          "type": "boolean",
          "description": "Whether this node isLong"
        },
        {
          "name": "@isDecimal",
          "type": "boolean",
          "description": "Whether this node isDecimal"
        },
        {
          "name": "@isNull",
          "type": "boolean",
          "description": "Whether this node isNull"
        },
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        },
        {
          "name": "@Name",
          "type": "string",
          "description": "Returns the name of this literal when it is labeled in an object initializer with named arguments ({@link ASTNewKeyValueObjectExpression}). <p>For example, in the Apex code <pre>{@code new X(a = 1, b = 2) }</pre> , the {@link ASTLiteralExpression} corresponding to {@code 2} will have the {@code name} \"{@code b}\"."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "MapEntryNode": {
      "name": "MapEntryNode",
      "description": "Represents map entry node",
      "category": "Other",
      "extends": "AbstractApexNode.Many",
      "implements": [],
      "attributes": [
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Many",
        "AbstractApexNode"
      ]
    },
    "Method": {
      "name": "Method",
      "description": "Represents a method declaration",
      "category": "Declarations",
      "extends": "AbstractApexNode",
      "implements": [
        "ApexQualifiableNode"
      ],
      "attributes": [
        {
          "name": "@RealLoc",
          "type": "boolean",
          "description": "Internal name used by the synthetic trigger method."
        },
        {
          "name": "@Image",
          "type": "string",
          "description": "Internal name used by the synthetic trigger method."
        },
        {
          "name": "@CanonicalName",
          "type": "string",
          "description": "Internal name used by the synthetic trigger method."
        },
        {
          "name": "@QualifiedName",
          "type": "string",
          "description": "Internal name used by the synthetic trigger method."
        },
        {
          "name": "@isConstructor",
          "type": "boolean",
          "description": "Internal name used by the synthetic trigger method."
        },
        {
          "name": "@isStaticInitializer",
          "type": "boolean",
          "description": "Internal name used by the synthetic trigger method."
        },
        {
          "name": "@Modifiers",
          "type": "node",
          "description": "Internal name used by the synthetic trigger method."
        },
        {
          "name": "@ReturnType",
          "type": "string",
          "description": "Returns the method return type name. This includes any type arguments. If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@Arity",
          "type": "integer",
          "description": "Returns the method return type name. This includes any type arguments. If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@isTriggerBlock",
          "type": "boolean",
          "description": "Checks whether this method is the synthetic trigger method."
        }
      ],
      "inherits": [
        "AbstractApexNode"
      ]
    },
    "MethodBlockStatement": {
      "name": "MethodBlockStatement",
      "description": "Represents method block statement",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "MethodCallExpression": {
      "name": "MethodCallExpression",
      "description": "Represents a method call expression",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@MethodName",
          "type": "string",
          "description": "The {@link Identifier}s that constitute the {@link CallExpression#getReceiver() receiver} of this method call."
        },
        {
          "name": "@FullMethodName",
          "type": "string",
          "description": "The {@link Identifier}s that constitute the {@link CallExpression#getReceiver() receiver} of this method call."
        },
        {
          "name": "@InputParametersSize",
          "type": "integer",
          "description": "The {@link Identifier}s that constitute the {@link CallExpression#getReceiver() receiver} of this method call."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "Modifier": {
      "name": "Modifier",
      "description": "Represents modifier",
      "category": "Modifiers",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ModifierNode": {
      "name": "ModifierNode",
      "description": "Represents modifier node",
      "category": "Modifiers",
      "extends": "AbstractApexNode.Many",
      "implements": [
        "AccessNode"
      ],
      "attributes": [
        {
          "name": "@Modifiers",
          "type": "integer",
          "description": "The modifiers of this node"
        },
        {
          "name": "@isPublic",
          "type": "boolean",
          "description": "Whether this node isPublic"
        },
        {
          "name": "@isProtected",
          "type": "boolean",
          "description": "Whether this node isProtected"
        },
        {
          "name": "@isPrivate",
          "type": "boolean",
          "description": "Whether this node isPrivate"
        },
        {
          "name": "@isAbstract",
          "type": "boolean",
          "description": "Whether this node isAbstract"
        },
        {
          "name": "@isStatic",
          "type": "boolean",
          "description": "Whether this node isStatic"
        },
        {
          "name": "@isFinal",
          "type": "boolean",
          "description": "Whether this node isFinal"
        },
        {
          "name": "@isTransient",
          "type": "boolean",
          "description": "Whether this node isTransient"
        },
        {
          "name": "@isTest",
          "type": "boolean",
          "description": "Returns true if function has `@isTest` annotation or `testmethod` modifier"
        },
        {
          "name": "@DeprecatedTestMethod",
          "type": "boolean",
          "description": "Returns true if function has `testmethod` modifier"
        },
        {
          "name": "@isTestOrTestSetup",
          "type": "boolean",
          "description": "Returns true if function has `testmethod` modifier"
        },
        {
          "name": "@isWithSharing",
          "type": "boolean",
          "description": "Returns true if function has `testmethod` modifier"
        },
        {
          "name": "@isWithoutSharing",
          "type": "boolean",
          "description": "Returns true if function has `testmethod` modifier"
        },
        {
          "name": "@isInheritedSharing",
          "type": "boolean",
          "description": "Returns true if function has `testmethod` modifier"
        },
        {
          "name": "@isWebService",
          "type": "boolean",
          "description": "Returns true if function has `testmethod` modifier"
        },
        {
          "name": "@isGlobal",
          "type": "boolean",
          "description": "Returns true if function has `testmethod` modifier"
        },
        {
          "name": "@isOverride",
          "type": "boolean",
          "description": "Returns true if function has `testmethod` modifier"
        },
        {
          "name": "@isVirtual",
          "type": "boolean",
          "description": "Returns true if function has `testmethod` modifier"
        }
      ],
      "inherits": [
        "AbstractApexNode.Many",
        "AbstractApexNode"
      ]
    },
    "ModifierOrAnnotation": {
      "name": "ModifierOrAnnotation",
      "description": "Represents modifier or annotation",
      "category": "Modifiers",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "MultiStatement": {
      "name": "MultiStatement",
      "description": "Represents multi statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "NestedExpression": {
      "name": "NestedExpression",
      "description": "Represents nested expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "NestedStoreExpression": {
      "name": "NestedStoreExpression",
      "description": "Represents nested store expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "NewKeyValueObjectExpression": {
      "name": "NewKeyValueObjectExpression",
      "description": "Represents new key value object expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Type",
          "type": "string",
          "description": "Returns the type name. This includes any type arguments. If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@ParameterCount",
          "type": "integer",
          "description": "Returns the type name. This includes any type arguments. If the type is a primitive, its case will be normalized."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "NewListInitExpression": {
      "name": "NewListInitExpression",
      "description": "Represents new list init expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "NewListLiteralExpression": {
      "name": "NewListLiteralExpression",
      "description": "Represents new list literal expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "NewMapInitExpression": {
      "name": "NewMapInitExpression",
      "description": "Represents new map init expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "NewMapLiteralExpression": {
      "name": "NewMapLiteralExpression",
      "description": "Represents new map literal expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "NewObjectExpression": {
      "name": "NewObjectExpression",
      "description": "Represents new object expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Type",
          "type": "string",
          "description": "Returns the type name. This includes any type arguments. If the type is a primitive, its case will be normalized."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "NewSetInitExpression": {
      "name": "NewSetInitExpression",
      "description": "Represents new set init expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "NewSetLiteralExpression": {
      "name": "NewSetLiteralExpression",
      "description": "Represents new set literal expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "PackageVersionExpression": {
      "name": "PackageVersionExpression",
      "description": "Represents package version expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "Parameter": {
      "name": "Parameter",
      "description": "Represents parameter",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        },
        {
          "name": "@Modifiers",
          "type": "node",
          "description": "The modifiers of this node"
        },
        {
          "name": "@Type",
          "type": "string",
          "description": "Returns the parameter's type name. <p>This includes any type arguments. If the type is a primitive, its case will be normalized."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "PostfixExpression": {
      "name": "PostfixExpression",
      "description": "Represents postfix expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Op",
          "type": "string",
          "description": "The op of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "PrefixExpression": {
      "name": "PrefixExpression",
      "description": "Represents prefix expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Op",
          "type": "string",
          "description": "The op of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "Property": {
      "name": "Property",
      "description": "Represents property",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Type",
          "type": "string",
          "description": "Returns the property value's type name. This includes any type arguments. If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@Modifiers",
          "type": "node",
          "description": "Returns the property value's type name. This includes any type arguments. If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@FormatAccessorName",
          "type": "string",
          "description": "Returns the internal accessor (getter/setter) name of an {@link ASTProperty}. The accessor name is the constant {@link #ACCESSOR_PREFIX} prepended to the name of the property.",
          "parameters": [
            "ASTProperty property"
          ]
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ReferenceExpression": {
      "name": "ReferenceExpression",
      "description": "Represents reference expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Many",
      "implements": [],
      "attributes": [
        {
          "name": "@ReferenceType",
          "type": "string",
          "description": "The referencetype of this node"
        },
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        },
        {
          "name": "@Names",
          "type": "array",
          "description": "The names of this node"
        },
        {
          "name": "@isSafeNav",
          "type": "boolean",
          "description": "Whether this node isSafeNav"
        },
        {
          "name": "@isSObjectType",
          "type": "boolean",
          "description": "Whether this node isSObjectType"
        },
        {
          "name": "@RealLoc",
          "type": "boolean",
          "description": "Whether this node hasRealLoc"
        }
      ],
      "inherits": [
        "AbstractApexNode.Many",
        "AbstractApexNode"
      ]
    },
    "ReturnStatement": {
      "name": "ReturnStatement",
      "description": "Represents a return statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "RunAsBlockStatement": {
      "name": "RunAsBlockStatement",
      "description": "Represents run as block statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "SoqlExpression": {
      "name": "SoqlExpression",
      "description": "Represents a SOQL query expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Query",
          "type": "string",
          "description": "Returns the raw query as it appears in the source code."
        },
        {
          "name": "@CanonicalQuery",
          "type": "string",
          "description": "Returns the query with the SOQL keywords normalized as uppercase."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "SoslExpression": {
      "name": "SoslExpression",
      "description": "Represents a SOSL search expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Query",
          "type": "string",
          "description": "Returns the raw query as it appears in the source code."
        },
        {
          "name": "@CanonicalQuery",
          "type": "string",
          "description": "Returns the query with the SOSL keywords normalized as uppercase."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "StandardCondition": {
      "name": "StandardCondition",
      "description": "Represents standard condition",
      "category": "Other",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "Statement": {
      "name": "Statement",
      "description": "Represents statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "StatementExecuted": {
      "name": "StatementExecuted",
      "description": "Represents statement executed",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "SuperMethodCallExpression": {
      "name": "SuperMethodCallExpression",
      "description": "Represents super method call expression",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "SuperVariableExpression": {
      "name": "SuperVariableExpression",
      "description": "Represents super variable expression",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "SwitchStatement": {
      "name": "SwitchStatement",
      "description": "Represents switch statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "TernaryExpression": {
      "name": "TernaryExpression",
      "description": "Represents ternary expression",
      "category": "Expressions",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ThisMethodCallExpression": {
      "name": "ThisMethodCallExpression",
      "description": "Represents this method call expression",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ThisVariableExpression": {
      "name": "ThisVariableExpression",
      "description": "Represents this variable expression",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ThrowStatement": {
      "name": "ThrowStatement",
      "description": "Represents throw statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "TriggerVariableExpression": {
      "name": "TriggerVariableExpression",
      "description": "Represents trigger variable expression",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "TryCatchFinallyBlockStatement": {
      "name": "TryCatchFinallyBlockStatement",
      "description": "Represents try catch finally block statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@TryBlock",
          "type": "string",
          "description": "The tryblock of this node"
        },
        {
          "name": "@CatchClauses",
          "type": "array",
          "description": "The catchclauses of this node"
        },
        {
          "name": "@FinallyBlock",
          "type": "string",
          "description": "The finallyblock of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "TypeWhenBlock": {
      "name": "TypeWhenBlock",
      "description": "Represents type when block",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Type",
          "type": "string",
          "description": "Returns the when block's matching type name. This includes any type arguments. If the type is a primitive, its case will be normalized."
        },
        {
          "name": "@Name",
          "type": "string",
          "description": "Returns the when block's matching type name. This includes any type arguments. If the type is a primitive, its case will be normalized."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "UserClass": {
      "name": "UserClass",
      "description": "Represents an Apex class declaration (Note: Use UserClass, not ClassNode)",
      "category": "Declarations",
      "extends": "BaseApexClass",
      "implements": [
        "ASTUserClassOrInterface<ClassDeclaration>"
      ],
      "attributes": [
        {
          "name": "@SuperClassName",
          "type": "string",
          "description": "Returns the name of the superclass of this class, or an empty string if there is none. The type name does NOT include type arguments."
        },
        {
          "name": "@InterfaceNames",
          "type": "array",
          "description": "Returns a list of the names of the interfaces implemented by this class. The type names do NOT include type arguments. (This is tested.)"
        }
      ],
      "inherits": [
        "BaseApexClass",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "UserClassMethods": {
      "name": "UserClassMethods",
      "description": "Represents user class methods",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "UserEnum": {
      "name": "UserEnum",
      "description": "Represents an Apex enum declaration",
      "category": "Declarations",
      "extends": "BaseApexClass",
      "implements": [],
      "attributes": [
        {
          "name": "@QualifiedName",
          "type": "string",
          "description": "The qualifiedname of this node"
        }
      ],
      "inherits": [
        "BaseApexClass",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "UserExceptionMethods": {
      "name": "UserExceptionMethods",
      "description": "Represents user exception methods",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "UserInterface": {
      "name": "UserInterface",
      "description": "Represents an Apex interface declaration",
      "category": "Declarations",
      "extends": "BaseApexClass",
      "implements": [
        "ASTUserClassOrInterface<InterfaceDeclaration>"
      ],
      "attributes": [
        {
          "name": "@SuperInterfaceName",
          "type": "string",
          "description": "Returns the name of the superclass of this class, or an empty string if there is none. The type name does NOT include type arguments."
        }
      ],
      "inherits": [
        "BaseApexClass",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "UserTrigger": {
      "name": "UserTrigger",
      "description": "Represents an Apex trigger declaration (Note: Use UserTrigger, not TriggerNode)",
      "category": "Declarations",
      "extends": "BaseApexClass",
      "implements": [],
      "attributes": [
        {
          "name": "@TargetName",
          "type": "string",
          "description": "The targetname of this node"
        },
        {
          "name": "@Usages",
          "type": "array",
          "description": "The usages of this node"
        }
      ],
      "inherits": [
        "BaseApexClass",
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "ValueWhenBlock": {
      "name": "ValueWhenBlock",
      "description": "Represents value when block",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "VariableDeclaration": {
      "name": "VariableDeclaration",
      "description": "Represents a variable declaration statement",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        },
        {
          "name": "@Type",
          "type": "string",
          "description": "Returns the variable's type name. <p>This includes any type arguments. If the type is a primitive, its case will be normalized."
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "VariableDeclarationStatements": {
      "name": "VariableDeclarationStatements",
      "description": "Represents variable declaration statements",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Modifiers",
          "type": "node",
          "description": "The modifiers of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "VariableExpression": {
      "name": "VariableExpression",
      "description": "Represents a reference to a variable",
      "category": "Declarations",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [
        {
          "name": "@Image",
          "type": "string",
          "description": "The image of this node"
        }
      ],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    },
    "WhileLoopStatement": {
      "name": "WhileLoopStatement",
      "description": "Represents a while loop statement",
      "category": "Statements",
      "extends": "AbstractApexNode.Single",
      "implements": [],
      "attributes": [],
      "inherits": [
        "AbstractApexNode.Single",
        "AbstractApexNode"
      ]
    }
  },
  "xpath_pattern_catalog": {
    "description": "XPath patterns extracted from PMD Apex rules (minimal format for LLM learning)",
    "extracted_at": "2025-12-18",
    "pmd_version": "7.18.0",
    "total_rules": 17,
    "patterns": [
      {
        "rule_name": "ApexUnitTestMethodShouldHaveIsTestAnnotation",
        "description": "Apex test methods should have `@isTest` annotation instead of the `testMethod` keyword,\nas `testMethod` is deprecated.\nSalesforce advices to use [@isTest](https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_annotation_isTest.htm)\nannotation for test classes and methods.",
        "message": "Apex test methods should have @isTest annotation.",
        "xpath": "//Method[ModifierNode[@DeprecatedTestMethod = true()]]"
      },
      {
        "rule_name": "AvoidFutureAnnotation",
        "description": "Usage of the `@Future` annotation should be limited. The `@Future` annotation is a legacy way to execute asynchronous Apex code, but it has several limitations:\n- Methods must be static\n- Only primitive data types, primitive arrays, or collections of primitive data types can be parameters\n- No way to monitor job status or handle failures\n- No support for chaining jobs\n\nConsider implementing the `Queueable` interface instead, which provides:\n- Better error handling and monitoring capabilities\n- Support for more complex data types\n- Ability to chain jobs\n\nSee more here: <https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_queueing_jobs.htm>",
        "message": "Usage of @Future annotation should be limited. Consider implementing the Queueable interface instead.",
        "xpath": "//Method/ModifierNode/Annotation[lower-case(@Name) = 'future']"
      },
      {
        "rule_name": "DebugsShouldUseLoggingLevel",
        "description": "The first parameter of System.debug, when using the signature with two parameters, is a LoggingLevel enum.\n\nHaving the Logging Level specified provides a cleaner log, and improves readability of it.",
        "message": "Calls to System.debug should specify a logging level.",
        "xpath": "//MethodCallExpression[lower-case(@FullMethodName)='system.debug'][count(*)=2\n    or ($strictMode=true() and count(*)=3 and lower-case(VariableExpression/@Image)='debug')]"
      },
      {
        "rule_name": "ForLoopsMustUseBraces",
        "description": "Avoid using 'for' statements without using surrounding braces. If the code formatting or\nindentation is lost then it becomes difficult to separate the code being controlled\nfrom the rest.",
        "message": "Avoid using 'for' statements without curly braces",
        "xpath": "//ForLoopStatement/BlockStatement[@CurlyBrace= false()]\n|\n//ForEachStatement/BlockStatement[@CurlyBrace= false()]"
      },
      {
        "rule_name": "IfElseStmtsMustUseBraces",
        "description": "Avoid using if..else statements without using surrounding braces. If the code formatting\n            or indentation is lost then it becomes difficult to separate the code being controlled\n            from the rest.",
        "message": "Avoid using 'if...else' statements without curly braces",
        "xpath": "//IfBlockStatement/BlockStatement[@CurlyBrace= false()][count(child::*) > 0]\n|\n//IfElseBlockStatement/BlockStatement[@CurlyBrace= false()][count(child::*) > 0]"
      },
      {
        "rule_name": "IfStmtsMustUseBraces",
        "description": "Avoid using if statements without using braces to surround the code block. If the code\n            formatting or indentation is lost then it becomes difficult to separate the code being\n            controlled from the rest.",
        "message": "Avoid using if statements without curly braces",
        "xpath": "//IfBlockStatement/BlockStatement[@CurlyBrace= false()]"
      },
      {
        "rule_name": "OneDeclarationPerLine",
        "description": "Apex allows the use of several variables declaration of the same type on one line. However, it\ncan lead to quite messy code. This rule looks for several declarations on the same line.",
        "message": "Use one statement for each line, it enhances code readability.",
        "xpath": "//VariableDeclarationStatements\n  [count(VariableDeclaration) > 1 and ($reportInForLoopInitializer = true() or name(parent::*) != 'ForLoopStatement')]\n  [$strictMode or count(distinct-values(VariableDeclaration/@BeginLine)) != count(VariableDeclaration)]\n|\n//FieldDeclarationStatements\n  [count(FieldDeclaration) > 1]\n  [$strictMode or count(distinct-values(FieldDeclaration/VariableExpression/@BeginLine)) != count(FieldDeclaration/VariableExpression)]"
      },
      {
        "rule_name": "WhileLoopsMustUseBraces",
        "description": "Avoid using 'while' statements without using braces to surround the code block. If the code\nformatting or indentation is lost then it becomes difficult to separate the code being\ncontrolled from the rest.",
        "message": "Avoid using 'while' statements without curly braces",
        "xpath": "//WhileLoopStatement/BlockStatement[@CurlyBrace= false()]"
      },
      {
        "rule_name": "AvoidDirectAccessTriggerMap",
        "description": "Avoid directly accessing Trigger.old and Trigger.new as it can lead to a bug. Triggers should be bulkified and iterate through the map to handle the actions for each item separately.",
        "message": "Avoid directly accessing Trigger.old and Trigger.new",
        "xpath": "//ArrayLoadExpression[TriggerVariableExpression and LiteralExpression]"
      },
      {
        "rule_name": "EmptyCatchBlock",
        "description": "Empty Catch Block finds instances where an exception is caught, but nothing is done.\n      In most circumstances, this swallows an exception which should either be acted on\n      or reported.",
        "message": "Avoid empty catch blocks",
        "xpath": "//CatchBlockStatement[./BlockStatement[count(*) = 0] and\n    not(matches(@VariableName, $allowExceptionNameRegex)) and\n    ($allowCommentedBlocks = false() or @ContainsComment = false())]"
      },
      {
        "rule_name": "EmptyIfStmt",
        "description": "Empty If Statement finds instances where a condition is checked but nothing is done about it.",
        "message": "Avoid empty 'if' statements",
        "xpath": "//IfBlockStatement\n          [BlockStatement[count(*) = 0]]"
      },
      {
        "rule_name": "EmptyStatementBlock",
        "description": "Empty block statements serve no purpose and should be removed.",
        "message": "Avoid empty block statements.",
        "xpath": "//Method[$reportEmptyPrivateNoArgConstructor = true()\n    or (@Constructor != true()\n    or ./ModifierNode[@Private != true()]\n    or ./Parameter[count(*) > 0])]/ModifierNode[@Abstract != true()\n        and ($reportEmptyVirtualMethod = true() or @Virtual != true())\n        and ../BlockStatement[count(*) = 0]\n    ]\n| //Method/BlockStatement//BlockStatement\n    [not(parent::CatchBlockStatement)]\n    [count(*) = 0]\n    [@RealLoc = true()]"
      },
      {
        "rule_name": "EmptyTryOrFinallyBlock",
        "description": "Avoid empty try or finally blocks - what's the point?",
        "message": "Avoid empty try or finally blocks",
        "xpath": "//TryCatchFinallyBlockStatement[./BlockStatement[count(*) = 0]]"
      },
      {
        "rule_name": "EmptyWhileStmt",
        "description": "Empty While Statement finds all instances where a while statement does nothing.\n      If it is a timing loop, then you should use Thread.sleep() for it; if it is\n      a while loop that does a lot in the exit expression, rewrite it to make it clearer.",
        "message": "Avoid empty 'while' statements",
        "xpath": "//WhileLoopStatement[./BlockStatement[count(*) = 0]]"
      },
      {
        "rule_name": "TestMethodsMustBeInTestClasses",
        "description": "Test methods marked as a testMethod or annotated with @IsTest,\n      but not residing in a test class should be moved to a proper\n      class or have the @IsTest annotation added to the class.\n      \n      Support for tests inside functional classes was removed in Spring-13 (API Version 27.0),\n      making classes that violate this rule fail compile-time. This rule is mostly usable when\n      dealing with legacy code.",
        "message": "Test methods must be in test classes",
        "xpath": "//UserClass[\n      not(./ModifierNode/Annotation[lower-case(@Name) = 'istest']) and\n      (\n        (./Method/ModifierNode/Annotation[lower-case(@Name) = 'istest']) or\n        (./Method/ModifierNode[@Test = true()])\n      )\n    ]"
      },
      {
        "rule_name": "AvoidDebugStatements",
        "description": "Debug statements contribute to longer transactions and consume Apex CPU time even when debug logs are not being captured.\n\nWhen possible make use of other debugging techniques such as the Apex Replay Debugger and Checkpoints that could cover *most* use cases.\n\nFor other valid use cases that the statement is in fact valid make use of the `@SuppressWarnings` annotation or the `//NOPMD` comment.",
        "message": "Avoid debug statements since they impact on performance",
        "xpath": "//MethodCallExpression[lower-case(@FullMethodName)='system.debug']"
      },
      {
        "rule_name": "EagerlyLoadedDescribeSObjectResult",
        "description": "This rule finds `DescribeSObjectResult`s which could have been loaded eagerly via `SObjectType.getDescribe()`.\n\nWhen using `SObjectType.getDescribe()` or `Schema.describeSObjects()` without supplying a `SObjectDescribeOptions`,\nimplicitly it will be using `SObjectDescribeOptions.DEFAULT` and then all\nchild relationships will be loaded eagerly regardless whether this information is needed or not.\nThis has a potential negative performance impact. Instead [`SObjectType.getDescribe(options)`](https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_class_Schema_SObjectType.htm#unique_346834793)\nor [`Schema.describeSObjects(SObjectTypes, options)`](https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_methods_system_schema.htm#apex_System_Schema_describeSObjects)\nshould be used and a `SObjectDescribeOptions` should be supplied. By using\n`SObjectDescribeOptions.DEFERRED` the describe attributes will be lazily initialized at first use.\n\nLazy loading `DescribeSObjectResult` on picklist fields is not always recommended. The lazy loaded\ndescribe objects might not be 100% accurate. It might be safer to explicitly use\n`SObjectDescribeOptions.FULL` in such a case. The same applies when you need the same `DescribeSObjectResult`\nto be consistent across different contexts and API versions.\n\nProperties:\n\n* `noDefault`: The behavior of `SObjectDescribeOptions.DEFAULT` changes from API Version 43 to 44:\n    With API Version 43, the attributes are loaded eagerly. With API Version 44, they are loaded lazily.\n    Simply using `SObjectDescribeOptions.DEFAULT` doesn't automatically make use of lazy loading.\n    (unless \"Use Improved Schema Caching\" critical update is applied, `SObjectDescribeOptions.DEFAULT` does fallback\n    to lazy loading)\n    With this property enabled, such usages are found.\n    You might ignore this, if you can make sure, that you don't run a mix of API Versions.",
        "message": "DescribeSObjectResult could be being loaded eagerly with all child relationships.",
        "xpath": "//MethodCallExpression\n    [\n        lower-case(@MethodName) = \"getdescribe\" and ReferenceExpression[@SObjectType = true()]\n        or lower-case(@MethodName) = \"describesobjects\"\n    ]\n    [not(VariableExpression/ReferenceExpression\n            [lower-case(@Image) = (\"sobjectdescribeoptions\", \"fielddescribeoptions\")]\n         )\n    ]\n|\n//ReferenceExpression\n    [$noDefault = true()]\n    [lower-case(@Image) = \"sobjectdescribeoptions\"]\n    [parent::VariableExpression[lower-case(@Image) = \"default\"]]"
      }
    ]
  }
}